<!DOCTYPE html>
<html lang="fr">
 
<!-- Mirrored from lecluseo.scenari-community.org/CircuitPython/co/g_gpio.html by HTTraQt Website Copier/1.x [Karbofos 2012-2017] mer., 24 août 2022 06:41:05 GMT -->
<head>
  <meta http-equiv="x-ua-compatible" content="IE=EDGE">
  <title>Utiliser les entrées-sorties [Rendre les objets intelligents grâce à Python]</title>
  <meta charset="UTF-8">
  <meta name="generator" content="SCENARI 5.0.2 / Opale 3.7.001">
  <meta name="revision" content="2020-02-19 14:55">
  <link rel="start" href="module_Micropython.html" title="Rendre les objets intelligents gr&acirc;ce &agrave; Python">
  <meta name="author" content="Olivier L&eacute;cluse
Creative Common BY-NC-SA
">
  <meta name="keywords" content>
  <meta name="date" content="2 F&eacute;vrier 2019">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../lib-md/w_scImgMgr/scImgMgr.css">
  <link rel="stylesheet" type="text/css" href="../lib-md/w_scCodeMgr/scCodeMgr.css">
  <script type="text/JavaScript">
/*0*/ var scServices = {id:"k6tfv97s"};
/*1*/ window.scLoadParams = {destUri:"/co/g_gpio.html", pathToRoot:"../"};
</script>
  <script type="text/JavaScript" src="../lib-sc/scCoLib.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scSiLib.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scTiLib.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scPaLib.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scMapMgr.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scTooltipMgr.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scDynUiMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/s_assmnt.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scDragMgr.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scAssmntMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_mathjax/mathjaxMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/s_scSearch/scSearch.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_tplMgr/tplMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_scCodeMgr/scCodeMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_searchMgr/searchMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_scMediaMgr/scMediaMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_scImgMgr/scImgMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_outMgr/outMgr.js"></script>
  <script type="text/JavaScript">

/*0*/ try{if(window.opener && window.opener.scServices && window.opener.scServices.id == scServices.id) scServices = window.opener.scServices; else if(window.parent && window.parent.scServices && window.parent.scServices.id == scServices.id) scServices = window.parent.scServices;}catch(e){}
scCodeMgr.registerCode("des:div.code");

scImgMgr.registerAdaptedImage("ide:content/des:img");

scImgMgr.registerGallery("des:div.galFra");

scImgMgr.registerSvg("des:svg");
scImgMgr.registerZoom("des:a.svgZoom",{type:"svg",svgMax:1,toolbar:1,titlePath:"par:/nsi:/des:span.capTi"});

scImgMgr.registerZoom("des:a.imgZoom",{toolbar:1,mag:1,titlePath:"par:/nsi:/des:span.capTi"});

</script>
  <link type="text/css" rel="stylesheet" href="../skin/css/main.css" media="all">
  <link type="text/css" rel="stylesheet" href="../skin/css/skin.css" media="all">
  <link type="text/css" rel="stylesheet" href="../skin/css/print.css" media="print">
  <script type="text/JavaScript">
outMgr.declareOutline("module_Micropython.txt");
	</script> </head>
 <body class="default module expUc">
  <div id="root"><header id="header" role="banner"><h1><span>Rendre les objets intelligents grâce à Python</span></h1><nav role="navigation"><ul id="accessibility"><li class="waiContent"><a href="#content"><span>contenu</span></a></li><li class="waiMenu"><a href="#menu"><span>menu</span></a></li><li class="waiNav"><a href="#navigation"><span>navigation</span></a></li><li class="waiTools"><a href="#tools"><span>outils</span></a></li></ul></nav></header><main id="main" role="main"><div id="document"><div id="content" tabindex="-1"><div class="scroller"><hr class="hidden"><section class="hBk article expUc"><h2 class="hBk_ti"><span>Utiliser les entrées-sorties</span></h2><div class="hBk_co "><div class="warning pBk"><h3 class="warning_ti pBk_ti"><span><i class="type"><span>Attention</span></i><span class="hidden"> : </span><span class="title"></span></span></h3><div class="warning_co pBk_co"><div class="rBk "><p>Une mauvaise utilisation des entrées-sorties peut endommager votre carte. Attention à ne pas dépasser la tension ou le courant prévu pour chaque broche d'E/S.</p></div><div class="rBk "><p>La carte microbit fonctionne sur 3,3V, même si elle est alimentée par les 5V de l'USB. Il faut donc veiller à ne pas appliquer de tension supérieure à 3,3V sur les entrées sortie. En particulier il faudra être vigilant en cas d'utilisation de capteur nécessitant une tension de 5V.</p></div></div></div><div class="complement pBk"><h3 class="complement_ti pBk_ti"><span><i class="type"><span>Complément</span></i><span class="hidden"> : </span><span class="title">shield gator:bit</span></span></h3><div class="complement_co pBk_co"><div class="rBk "><p>Afin de protéger la carte de mauvaise manipulation, il est possible d'accéder aux entrées-sorties via un shield (carte additionelle sur laquelle la microbit vient se brancher). Personnellement, j'utilise le <a class="op_txt_ul" target="_blank" href="../../../external.html?link=https://www.mouser.fr/ProductDetail/SparkFun/DEV-15162?qs=sGAEpiMZZMve4%2FbfQkoj%252BNwqAFzgZ6qxFqEwoaxcVRA%3D" rel="noopener" title="shield gator:bit V2 (nouvelle fen&ecirc;tre)"><span>shield gator:bit V2</span></a> de sparkfun qui me satisfait sur le plan de la protection de la carte : une tension de 5V appliquée sur une E/S sera rabaissée et n'endommagera pas la microbit. En plus, ce shield offre 5 led RVB <i class="txt_spec_is ">neopixel</i>, un haut-parleur et un convertisseur de tension permettant d'alimenter la carte depuis une alimentation entre 2,7V et 9V.</p></div><div class="rBk "><p>Soyez vigilent de bien choisir la version 2 du shield, référence sparkfun DEV-15162.</p></div></div></div><div class="basic pBk"><h3 class="basic_ti pBk_ti"><span><i class="type"><span>Fondamental</span></i><span class="hidden"> : </span><span class="title">Information compléte</span></span></h3><div class="basic_co pBk_co"><div class="rBk "><p>Pour connaître le détail des spécificités de chaque broche de la microbit, je vous invite à consulter cette page :</p><p><a class="op_txt_ul" target="_blank" href="../../../external.html?link=https://microbit.org/guide/hardware/pins/" rel="noopener" title="https://microbit.org/guide/hardware/pins/ (nouvelle fen&ecirc;tre)"><span>https://microbit.org/guide/hardware/pins/</span></a></p></div></div></div><div class="iBk info"><h3 class="iBk_ti"><span>boutons tactiles</span></h3><div class="iBk_co "><div class="rBk "><p>Les broches 0, 1 et 2 sont - en théorie - tactiles. On peut détecter lorqu'on les touche. Pour ma part je ne trouve pas que cette détection soit très sensible et n'est pas vraiment utilisable. D'autre part, l'utilisation du shield gator:bit rend cette fonctionnalité inopérante.</p><p>Voici tout de même un exemple de code mettant en oeuvre la détection de toucher sir la broche pin0. Vous pourrez ainsi vous faire votre propre idée par vous-même.</p></div><div class="rBk listing"><div><div class="code"><div class="code-form "><div class="CodeMirror-static cm-s-default" data-lang="text/x-python"><div class="CodeMirror-code"><div class="CodeMirror-line"><div class="CodeMirror-linenumber">1</div><pre><span class="cm-keyword">from</span> <span class="cm-variable">microbit</span> <span class="cm-keyword">import</span> <span class="cm-operator">*</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">2</div><pre></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">3</div><pre><span class="cm-keyword">while</span> <span class="cm-keyword">True</span>:</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">4</div><pre>    <span class="cm-keyword">if</span> <span class="cm-variable">pin0</span>.<span class="cm-property">is_touched</span>():</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">5</div><pre>        <span class="cm-variable">display</span>.<span class="cm-property">show</span>(<span class="cm-variable">Image</span>.<span class="cm-property">HAPPY</span>)</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">6</div><pre>    <span class="cm-keyword">else</span>:</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">7</div><pre>        <span class="cm-variable">display</span>.<span class="cm-property">show</span>(<span class="cm-variable">Image</span>.<span class="cm-property">SAD</span>)</pre></div></div></div></div><pre class="code-raw noIndex " style="display:none;">from microbit import *

while True:
    if pin0.is_touched():
        display.show(Image.HAPPY)
    else:
        display.show(Image.SAD)</pre></div></div></div></div></div><div class="iBk info"><h3 class="iBk_ti"><span>Faire clignoter une LED</span></h3><div class="iBk_co "><div class="rBk "><p>Comment échapper à cet incontournable <i class="txt_spec_is ">blink </i>! Le code se passe de commentaire et illustre la méthode <strong class="txt_emp_is ">write_digital()</strong> qui s'applique sur les broches pinXX</p></div><div class="rBk listing"><div><div class="code"><div class="code-form "><div class="CodeMirror-static cm-s-default" data-lang="text/x-python"><div class="CodeMirror-code"><div class="CodeMirror-line"><div class="CodeMirror-linenumber">1</div><pre><span class="cm-keyword">from</span> <span class="cm-variable">microbit</span> <span class="cm-keyword">import</span> <span class="cm-operator">*</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">2</div><pre></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">3</div><pre><span class="cm-keyword">while</span> <span class="cm-keyword">True</span>:</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">4</div><pre>    <span class="cm-variable">pin0</span>.<span class="cm-property">write_digital</span>(<span class="cm-number">1</span>)</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">5</div><pre>    <span class="cm-variable">sleep</span>(<span class="cm-number">500</span>)</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">6</div><pre>    <span class="cm-variable">pin0</span>.<span class="cm-property">write_digital</span>(<span class="cm-number">0</span>)</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">7</div><pre>    <span class="cm-variable">sleep</span>(<span class="cm-number">500</span>)</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">8</div><pre></pre></div></div></div></div><pre class="code-raw noIndex " style="display:none;">from microbit import *

while True:
    pin0.write_digital(1)
    sleep(500)
    pin0.write_digital(0)
    sleep(500)
</pre></div></div></div></div></div><div class="iBk info"><h3 class="iBk_ti"><span>Entrée numérique</span></h3><div class="iBk_co "><div class="rBk "><p>Pour configurer la broche 1 en entrée numérique avec résistance de PULL_UP, on tulise les commandes suivantes :</p><p><code class="txt_code_is ">&gt;&gt;&gt; pin1.set_pull(pin1.PULL_UP)</code></p><p>les autres options de PULL sont <strong class="txt_emp_is ">PULL_DOWN</strong> et <strong class="txt_emp_is ">NO_PULL</strong></p></div><div class="rBk "><p>On peut ensuite lire la broche en faisant</p><p><code class="txt_code_is ">&gt;&gt;&gt; pin1.read_digital()</code></p><p>qui renvoie 1 si la broche est à l'état haut, ou 0 à l'état bas.</p></div></div></div><div class="complement pBk"><h3 class="complement_ti pBk_ti"><span><i class="type"><span>Complément</span></i><span class="hidden"> : </span><span class="title">Connaître la configuration d'une broche</span></span></h3><div class="complement_co pBk_co"><div class="rBk "><p>Pour savoir si une broche est configurée en entrée (INPUT) ou en sortie (OUTPUT), on peut taper</p><p><code class="txt_code_is ">&gt;&gt;&gt;pin1.get_mode()</code></p><p>renvoie par exemple <strong class="txt_emp_is ">'read_digital'</strong> ou <strong class="txt_emp_is ">'write_digital'</strong></p></div><div class="rBk "><p>La configuration des broches en <i class="txt_spec_is ">INPUT</i> ou <i class="txt_spec_is ">OUTPUT</i> se fait automatiquement selon qu'on fait un <strong class="txt_emp_is ">read_digital()</strong> ou un <strong class="txt_emp_is ">write_digital()</strong>. Par défaut les broches sont configurées en sortie. Essayez les commandes suivantes dans le <strong class="txt_emp_is ">REPL </strong>:</p><p><code class="txt_code_is ">&gt;&gt;&gt; pin1.get_mode()</code></p><p><code class="txt_code_is ">'write_digital'</code></p><p><code class="txt_code_is ">&gt;&gt;&gt; pin1.read_digital()</code></p><p><code class="txt_code_is ">&gt;&gt;&gt; pin1.get_mode()</code></p><p><code class="txt_code_is ">'read_digital'</code></p><p><code class="txt_code_is ">&gt;&gt;&gt; pin1.write_digital(0)</code></p><p><code class="txt_code_is ">&gt;&gt;&gt; pin1.get_mode()</code></p><p><code class="txt_code_is ">'write_digital'</code></p></div></div></div><div class="iBk info"><h3 class="iBk_ti"><span>Pulse-Width-Modulation (PWM) : Modulation en largeur d'impulsion</span></h3><div class="iBk_co "><div class="rBk "><p>Les broches ne savent délivrer que 0 ou 3,3V. Si on souhaite diminuer la luminosité d'une LED ou ralentir un moteur commandé par une broche de la microbit il est utile d'avoir recours au PWM afin de définir quel pourcentage de temps la broche sera à l'état haut.</p></div><div class="rBk "><p>La méthode permettant le PWM est write_analog et s'utilise ainsi :</p><p><code class="txt_code_is ">&gt;&gt;&gt; pin1.write_analog(512)</code></p><p><code class="txt_code_is ">&gt;&gt;&gt; pin1.get_mode()</code></p><p><code class="txt_code_is ">'write_analog'</code></p></div><div class="rBk "><p>Les valeurs acceptées sont sur 10 bits donc de 0 (toujours à 0) à 1023 (toujours à 1). L'exemple ci-dessus montre un rapport cyclique de 50% dont haut la moitié du temps sur une période donnée.</p></div></div></div><div class="iBk info"><h3 class="iBk_ti"><span>Entrée analogique</span></h3><div class="iBk_co "><div class="rBk "><p>Certaines broches (0, 1, 2, 3, 4, 10) peuvent recevoir une tension entre 0 et 3,3V. Elles renvoient alors une valeur lue entre 0 et 1023. La méthode à invoquer est <strong class="txt_emp_is ">read_analog()</strong> :</p><p><code class="txt_code_is ">&gt;&gt;&gt; pin1.read_analog()</code></p><p><code class="txt_code_is ">49</code></p></div></div></div><div class="complement pBk"><h3 class="complement_ti pBk_ti"><span><i class="type"><span>Complément</span></i><span class="hidden"> : </span><span class="title">Connaître les fonctionnalités acceptées par une broche</span></span></h3><div class="complement_co pBk_co"><div class="rBk "><p>La commande <strong class="txt_emp_is ">dir</strong> permet de lister les méthodes associées à une broche :</p><p><code class="txt_code_is ">&gt;&gt;&gt; dir(pin1)</code></p><p><code class="txt_code_is ">['write_digital', 'read_digital', 'write_analog', 'read_analog', 'set_analog_period', 'set_analog_period_microseconds', 'is_touched', 'PULL_UP', 'PULL_DOWN', 'NO_PULL', 'get_pull', 'set_pull', 'get_mode']</code></p><p><code class="txt_code_is ">&gt;&gt;&gt; dir(pin9)</code></p><p><code class="txt_code_is ">['write_digital', 'read_digital', 'write_analog', 'set_analog_period', 'set_analog_period_microseconds', 'get_analog_period_microseconds', 'PULL_UP', 'PULL_DOWN', 'NO_PULL', 'get_pull', 'set_pull', 'get_mode']</code></p><p>La broche 1 possède la fonctionnalité <strong class="txt_emp_is ">read_analog()</strong> mais pas la broche 9.</p></div></div></div><div class="remark pBk"><h3 class="remark_ti pBk_ti"><span><i class="type"><span>Remarque</span></i><span class="hidden"> : </span><span class="title"></span></span></h3><div class="remark_co pBk_co"><div class="rBk "><p>La microbit utilise des résistances externes de pullup faibles (10 Mohms) sur les broches 0, 1 et 2 afin de faire fonctionner la détection de toucher</p><p>Il y a aussi des résistances de pull-up externes de 10Kohms sur les broches 5 et 11 pour les boutons A et B</p><p>Les broches 1, 4, 6, 7, 9 et 10 sont utilisées pour la matrice de LEDs. Pour utiliser ces broches à d'autres usages, il faut éteindre l'écran (<strong class="txt_emp_is ">display.off()</strong>).</p></div></div></div></div></section></div></div><div id="navigation" tabindex="-1"><hr class="hidden"><nav class="pageTurner" role="navigation"><ul><li><a rel="prev" href="g_boutons.html" target="_self" class="btnNav prev" title="Pr&eacute;c&eacute;dent (Utiliser les boutons)"><span>Précédent</span></a></li><li><a rel="next" href="g_radio.html" target="_self" class="btnNav next" title="Suivant (Utiliser la communication radio)"><span>Suivant</span></a></li></ul></nav></div></div><div id="toolbox"><nav id="menu" class="pageSelector" role="navigation" tabindex="-1" aria-label="menu principal"><hr class="hidden"><ul class="mnu static" data-totalPages="80"><li class="sel_no anc_no type_l  dpt_0 intro"><div class="lbl type_l" id="module_Micropython_1.html"><a href="module_Micropython_1.html" target="_self" class="item"><span>Introduction</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_circuitPython.html"><a href="AA_circuitPython.html" target="_self" class="item"><span>Adafruit ? CircuitPython ?</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_edublocks.html"><a href="AA_edublocks.html" target="_self" class="item"><span>Découverte de CircuitPython avec edublocks</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_circuitPython_1.html"><a href="AA_circuitPython_1.html" target="_self" class="item"><span>de l'Arduino vers CircuitPython</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_mu.html"><a href="AA_mu.html" target="_self" class="item"><span>projets CPX</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_autresProjets.html"><a href="AA_autresProjets.html" target="_self" class="item"><span>Projets divers autour de CircuitPython</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_displayio.html"><a href="AA_displayio.html" target="_self" class="item"><span>Graphisme sous CircuitPython - utilisation de displayio</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="aa_gameConsole.html"><a href="aa_gameConsole.html" target="_self" class="item"><span>Fabriquer sa console de jeu - Niveau avancé</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 ueDiv"><div class="lbl type_b" id="module_Micropython_2.html"><a href="module_Micropython_2.html" target="_self" class="item"><span>Objets connectés (IoT) - MicroPython sur ESP8266 et ESP32</span></a></div></li><li class="sel_no anc_yes type_b  dpt_0 ueDiv"><div class="lbl type_b" id="module_Micropython_3.html"><a href="module_Micropython_3.html" target="_self" class="item" type="up"><span>Micropython sur la carte BBC micro::bit</span></a></div><ul class="sub mnu_open"><li class="sel_no anc_no type_l  dpt_1 intro"><div class="lbl type_l" id="module_Micropython_5.html"><a href="module_Micropython_5.html" target="_self" class="item"><span>Introduction</span></a></div></li><li class="sel_no anc_no type_l  dpt_1 expUc"><div class="lbl type_l" id="G_mu_1.html"><a href="G_mu_1.html" target="_self" class="item"><span>Utiliser l'éditeur Mu</span></a></div></li><li class="sel_no anc_yes type_b  dpt_1 courseUa"><div class="lbl type_b" id="AA_kitSurvie.html"><a href="AA_kitSurvie.html" target="_self" class="item" type="up"><span>kit de survie de la carte microbit sous MicroPython</span></a></div><ul class="sub mnu_open"><li class="sel_no anc_no type_l  dpt_2 intro"><div class="lbl type_l" id="AA_kitSurvie_1.html"><a href="AA_kitSurvie_1.html" target="_self" class="item"><span>Introduction</span></a></div></li><li class="sel_no anc_no type_l  dpt_2 expUc"><div class="lbl type_l" id="g_leds.html"><a href="g_leds.html" target="_self" class="item"><span>La matrice LED</span></a></div></li><li class="sel_no anc_no type_l  dpt_2 expUc"><div class="lbl type_l" id="g_boutons.html"><a href="g_boutons.html" target="_self" class="item"><span>Utiliser les boutons</span></a></div></li><li class="sel_yes anc_no type_l  dpt_2 expUc"><div class="lbl type_l" id="g_gpio.html"><span class="item"><span>Utiliser les entrées-sorties</span></span></div></li><li class="sel_no anc_no type_l  dpt_2 expUc"><div class="lbl type_l" id="g_radio.html"><a href="g_radio.html" target="_self" class="item"><span>Utiliser la communication radio</span></a></div></li><li class="sel_no anc_no type_l  dpt_2 expUc"><div class="lbl type_l" id="g_son.html"><a href="g_son.html" target="_self" class="item"><span>la gestion du son</span></a></div></li><li class="sel_no anc_no type_l  dpt_2 expUc"><div class="lbl type_l" id="g_temp.html"><a href="g_temp.html" target="_self" class="item"><span>Capteur de température</span></a></div></li><li class="sel_no anc_no type_l  dpt_2 expUc"><div class="lbl type_l" id="g_accel.html"><a href="g_accel.html" target="_self" class="item"><span>Utiliser l'accéléromètre</span></a></div></li><li class="sel_no anc_no type_l  dpt_2 expUc"><div class="lbl type_l" id="g_boussole.html"><a href="g_boussole.html" target="_self" class="item"><span>Utilisation de la boussole</span></a></div></li></ul></li><li class="sel_no anc_no type_l  dpt_1 expUc"><div class="lbl type_l" id="g_exosMB.html"><a href="g_exosMB.html" target="_self" class="item"><span>Activités de prise en main de la micro:bit</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_1 courseUa"><div class="lbl type_b" id="AA_projets.html"><a href="AA_projets.html" target="_self" class="item"><span>Mini-projets sur Microbit</span></a></div></li></ul></li></ul></nav><div id="tools" tabindex="-1"><hr class="hidden"><nav class="headingSelector" role="navigation"><ul class="mnu"><li class="anc_no home" data-position="uncle"><div class="lbl"><a href="module_Micropython.html" target="_self" class="item" type="index" title="Page d'accueil du module"><span>Accueil</span></a></div></li><li class="anc_yes module" data-position="ancestor"><div class="lbl"><span class="item"><span>Module</span></span></div></li></ul></nav></div></div></main><footer id="footer" role="contentinfo" tabindex="-1"><hr class="hidden"><a id="linkSp" target="_blank" href="../../../external.html?link=https://www.scenari.org/" title="R&eacute;alis&eacute; avec Scenari (nouvelle fen&ecirc;tre)"><span><img alt="R&eacute;alis&eacute; avec Scenari (nouvelle fen&ecirc;tre)" src="../skin/img/tpl/scBtn.png"></span></a></footer></div>
  <script type="text/JavaScript" src="../skin/js/skin.js"></script>
  <script type="text/javascript">tplMgr.init();scCodeMgr.init();scMediaMgr.init("ide:content/chi:div/chi:section/des:.mediaPlayer",{processYoutubeUrls :true});scImgMgr.init();outMgr.init();</script>
 </body>

<!-- Mirrored from lecluseo.scenari-community.org/CircuitPython/co/g_gpio.html by HTTraQt Website Copier/1.x [Karbofos 2012-2017] mer., 24 août 2022 06:41:05 GMT -->
</html>
