<!DOCTYPE html>
<html lang="fr">
 
<!-- Mirrored from lecluseo.scenari-community.org/CircuitPython/co/g_analogIn.html by HTTraQt Website Copier/1.x [Karbofos 2012-2017] mer., 24 août 2022 06:38:49 GMT -->
<head>
  <meta http-equiv="x-ua-compatible" content="IE=EDGE">
  <title>Entrées - sorties analogiques [Rendre les objets intelligents grâce à Python]</title>
  <meta charset="UTF-8">
  <meta name="generator" content="SCENARI 5.0.2 / Opale 3.7.001">
  <meta name="revision" content="2020-02-19 14:55">
  <link rel="start" href="module_Micropython.html" title="Rendre les objets intelligents gr&acirc;ce &agrave; Python">
  <meta name="author" content="Olivier L&eacute;cluse
Creative Common BY-NC-SA
">
  <meta name="keywords" content>
  <meta name="date" content="2 F&eacute;vrier 2019">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../lib-md/w_scImgMgr/scImgMgr.css">
  <link rel="stylesheet" type="text/css" href="../lib-md/w_scCodeMgr/scCodeMgr.css">
  <script type="text/JavaScript">
/*0*/ var scServices = {id:"k6tfv97s"};
/*1*/ window.scLoadParams = {destUri:"/co/g_analogIn.html", pathToRoot:"../"};
</script>
  <script type="text/JavaScript" src="../lib-sc/scCoLib.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scSiLib.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scTiLib.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scPaLib.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scMapMgr.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scTooltipMgr.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scDynUiMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/s_assmnt.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scDragMgr.js"></script>
  <script type="text/JavaScript" src="../lib-sc/scAssmntMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_mathjax/mathjaxMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/s_scSearch/scSearch.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_tplMgr/tplMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_scCodeMgr/scCodeMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_searchMgr/searchMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_scMediaMgr/scMediaMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_scImgMgr/scImgMgr.js"></script>
  <script type="text/JavaScript" src="../lib-md/w_outMgr/outMgr.js"></script>
  <script type="text/JavaScript">

/*0*/ try{if(window.opener && window.opener.scServices && window.opener.scServices.id == scServices.id) scServices = window.opener.scServices; else if(window.parent && window.parent.scServices && window.parent.scServices.id == scServices.id) scServices = window.parent.scServices;}catch(e){}
scCodeMgr.registerCode("des:div.code");

scImgMgr.registerAdaptedImage("ide:content/des:img");

scImgMgr.registerGallery("des:div.galFra");

scImgMgr.registerSvg("des:svg");
scImgMgr.registerZoom("des:a.svgZoom",{type:"svg",svgMax:1,toolbar:1,titlePath:"par:/nsi:/des:span.capTi"});

scImgMgr.registerZoom("des:a.imgZoom",{toolbar:1,mag:1,titlePath:"par:/nsi:/des:span.capTi"});

</script>
  <link type="text/css" rel="stylesheet" href="../skin/css/main.css" media="all">
  <link type="text/css" rel="stylesheet" href="../skin/css/skin.css" media="all">
  <link type="text/css" rel="stylesheet" href="../skin/css/print.css" media="print">
  <script type="text/JavaScript">
outMgr.declareOutline("module_Micropython.txt");
	</script> </head>
 <body class="default module expUc">
  <div id="root"><header id="header" role="banner"><h1><span>Rendre les objets intelligents grâce à Python</span></h1><nav role="navigation"><ul id="accessibility"><li class="waiContent"><a href="#content"><span>contenu</span></a></li><li class="waiMenu"><a href="#menu"><span>menu</span></a></li><li class="waiNav"><a href="#navigation"><span>navigation</span></a></li><li class="waiTools"><a href="#tools"><span>outils</span></a></li></ul></nav></header><main id="main" role="main"><div id="document"><div id="content" tabindex="-1"><div class="scroller"><hr class="hidden"><section class="hBk article expUc"><h2 class="hBk_ti"><span>Entrées - sorties analogiques</span></h2><div class="hBk_co "><section class="hBk expUcDiv"><h3 class="hBk_ti"><span>Entrée analogique</span></h3><div class="hBk_co "><div class="iBk info"><div class="iBk_co "><div class="rBk "><p>Dans cette partie, nous allons voir comment récupérer l'information depuis un capteur analogique. Cela peut être un potentiomètre, une photorésistance pour lire la luminosité ambiante, un capteur de température type LM35, etc...</p></div><div class="rBk "><p>Sur Arduino, on utilise la fonction <code class="txt_code_is ">analogRead()</code> qui renvoie un entier entre 0 et 1023 car le convertisseur analogique-numérique (ADC) fonctionne sur 10 bits.</p></div><div class="rBk "><p>Sur les cartes Adafruit M0 et M4, nous avons un convertisseur ADC sur 12 bits, ce qui permet une bien meilleure précision dans la lecture des informations.</p></div></div></div><div class="method pBk"><h4 class="method_ti pBk_ti"><span><i class="type"><span>Méthode</span></i><span class="hidden"> : </span><span class="title">Lecture d'une information analogique</span></span></h4><div class="method_co pBk_co"><div class="rBk "><div class="txtRes "><div class="img lft "><figure role="group" class="resInFlow png"><div class="resInFlow_co "><a href="../res/ldr.png" class="imgZoom" target="_blank" onclick="scImgMgr.loading(); return false;" title="Cliquez pour agrandir (nouvelle fen&ecirc;tre)"><img src="../res/ldr_1.png" width="224" height="300" alt></a></div></figure></div><div class="txt "><p>Dans notre exemple, nous allons lire la luminosité ambiante à partir d'une photorésistance. Nous utiliserons le montage suivant. C'est un grand classique quand il s'agit d'utiliser une photorésistance. On crée un pont diviseur de tension entre la photorésistance et une résistance de 10Kohms puis on lit la tension variable au milieu.</p><p>Attention toutefois : la carte Adafruit - contrairement à l'Arduino - accepte des <strong class="txt_emp_is ">tensions maximales sur ses broches de 3,3V</strong>. On alimente donc notre montage depuis la sortie 3,3V et non 5V !</p></div></div></div><div class="rBk listing"><div><div class="code"><div class="code-form "><div class="CodeMirror-static cm-s-default" data-lang="text/x-python"><div class="CodeMirror-code"><div class="CodeMirror-line"><div class="CodeMirror-linenumber">1</div><pre><span class="cm-keyword">import</span> <span class="cm-variable">time</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">2</div><pre><span class="cm-keyword">import</span> <span class="cm-variable">board</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">3</div><pre><span class="cm-keyword">import</span> <span class="cm-variable">analogio</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">4</div><pre></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">5</div><pre><span class="cm-variable">adc</span> = <span class="cm-variable">analogio</span>.<span class="cm-property">AnalogIn</span>(<span class="cm-variable">board</span>.<span class="cm-property">A0</span>)</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">6</div><pre></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">7</div><pre><span class="cm-keyword">while</span> <span class="cm-keyword">True</span>:</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">8</div><pre>    <span class="cm-variable">tension</span> = <span class="cm-variable">adc</span>.<span class="cm-property">value</span> <span class="cm-operator">*</span> <span class="cm-variable">adc</span>.<span class="cm-property">reference_voltage</span> <span class="cm-operator">/</span> <span class="cm-number">65535</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">9</div><pre>    <span class="cm-builtin">print</span>((<span class="cm-variable">tension</span>, ))</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">10</div><pre>    <span class="cm-variable">time</span>.<span class="cm-property">sleep</span>(<span class="cm-number">1</span>)</pre></div></div></div></div><pre class="code-raw noIndex " style="display:none;">import time
import board
import analogio

adc = analogio.AnalogIn(board.A0)

while True:
    tension = adc.value * adc.reference_voltage / 65535
    print((tension, ))
    time.sleep(1)</pre></div></div></div><div class="rBk res"><figure role="group" class="resInFlow png"><div class="resInFlow_co "><img src="../res/capmu.png" width="578" height="529" alt></div></figure></div></div></div><div class="complement pBk"><h4 class="complement_ti pBk_ti"><span><i class="type"><span>Complément</span></i><span class="hidden"> : </span><span class="title">Explications</span></span></h4><div class="complement_co pBk_co"><div class="rBk "><ul class="txt_il "><li class="txt_ili "><p>Nous utilisons cette fois-ci la librairie <i class="txt_spec_is ">analogio</i>. Celle-ci gère les entrées via AnalogIn, mais aussi les sorties via AnalogOut. Les sorties analogiques n'existent pas sur l'Arduino.</p></li><li class="txt_ili "><p>La lecture de la broche se fait depuis l'objet <code class="txt_code_is ">adc</code>.</p></li><li class="txt_ili "><p><code class="txt_code_is ">adc.reference_voltage</code> contient 3.3. C'est la tension de référence.</p></li><li class="txt_ili "><p><code class="txt_code_is ">adc.value</code> renvoie un entier non signé sur 16 bits - donc entre 0 et 65535. Néanmoins la carte n'échantillonne que sur 12 bits. Les valeurs sont donc comptées de 16 en 16.</p></li></ul></div></div></div></div></section><section class="hBk expUcDiv"><h3 class="hBk_ti"><span>Sortie analogique</span></h3><div class="hBk_co "><div class="iBk info"><div class="iBk_co "><div class="rBk "><p>La plupart des cartes n'ont pas de sortie analogique. Elles utilisent une sortie numérique modulée en largeur d'impulsion (PWM) pour simuler une tension intermédiaire. La carte Adafruit Metro M4 possède deux sorties analogiques (DAC) sur A0 et A1 (La carte Metro M0 comme la CPX n'en possède qu'une seule sur A0). L'utilisation est très simple. Nous allons dans l'exemple qui suit en voir une illustration.</p></div></div></div><div class="method pBk"><h4 class="method_ti pBk_ti"><span><i class="type"><span>Méthode</span></i><span class="hidden"> : </span><span class="title"></span></span></h4><div class="method_co pBk_co"><div class="rBk "><div class="txtRes "><div class="txt "><p>Dans le montage ci-contre, nous allons mesurer l'illumination à l'aide d'un voltmètre : plus la luminosité ambiante est forte, plus la tension mesurée sera élevée.</p><p>Le code est très simple. Il faut simplement noter que les valeurs pour la sortie analogique sont sur 12 bits donc entre 0 et 4095.</p><p>Comme on peut le constater, les valeurs lues sur le voltmètres sont cohérentes avec les lectures faites à la partie précédente.</p></div><div class="img rgt "><figure role="group" class="resInFlow jpeg"><div class="resInFlow_co "><a href="../res/IMG_0428.JPG" class="imgZoom" target="_blank" onclick="scImgMgr.loading(); return false;" title="Cliquez pour agrandir (nouvelle fen&ecirc;tre)"><img src="../res/IMG_0428_1.JPG" width="300" height="225" alt></a></div></figure></div></div></div><div class="rBk listing"><div><div class="code"><div class="code-form "><div class="CodeMirror-static cm-s-default" data-lang="text/x-python"><div class="CodeMirror-code"><div class="CodeMirror-line"><div class="CodeMirror-linenumber">1</div><pre><span class="cm-keyword">import</span> <span class="cm-variable">time</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">2</div><pre><span class="cm-keyword">import</span> <span class="cm-variable">board</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">3</div><pre><span class="cm-keyword">import</span> <span class="cm-variable">analogio</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">4</div><pre></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">5</div><pre><span class="cm-variable">adc</span> = <span class="cm-variable">analogio</span>.<span class="cm-property">AnalogIn</span>(<span class="cm-variable">board</span>.<span class="cm-property">A0</span>)</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">6</div><pre><span class="cm-variable">dac</span> = <span class="cm-variable">analogio</span>.<span class="cm-property">AnalogOut</span>(<span class="cm-variable">board</span>.<span class="cm-property">A1</span>)</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">7</div><pre></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">8</div><pre><span class="cm-keyword">while</span> <span class="cm-keyword">True</span>:</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">9</div><pre>    <span class="cm-variable">tension</span> = <span class="cm-variable">adc</span>.<span class="cm-property">value</span> <span class="cm-operator">*</span> <span class="cm-variable">adc</span>.<span class="cm-property">reference_voltage</span> <span class="cm-operator">/</span> <span class="cm-number">65535</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">10</div><pre>    <span class="cm-variable">dac</span>.<span class="cm-property">value</span> = <span class="cm-variable">adc</span>.<span class="cm-property">value</span><span class="cm-operator">//</span><span class="cm-number">16</span></pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">11</div><pre>    <span class="cm-builtin">print</span>(<span class="cm-variable">adc</span>.<span class="cm-property">value</span>)</pre></div><div class="CodeMirror-line"><div class="CodeMirror-linenumber">12</div><pre>    <span class="cm-variable">time</span>.<span class="cm-property">sleep</span>(<span class="cm-number">1</span>)</pre></div></div></div></div><pre class="code-raw noIndex " style="display:none;">import time
import board
import analogio

adc = analogio.AnalogIn(board.A0)
dac = analogio.AnalogOut(board.A1)

while True:
    tension = adc.value * adc.reference_voltage / 65535
    dac.value = adc.value//16
    print(adc.value)
    time.sleep(1)</pre></div></div></div></div></div></div></section></div></section></div></div><div id="navigation" tabindex="-1"><hr class="hidden"><nav class="pageTurner" role="navigation"><ul><li><a rel="prev" href="g_button.html" target="_self" class="btnNav prev" title="Pr&eacute;c&eacute;dent (Entr&eacute;e num&eacute;rique)"><span>Précédent</span></a></li><li><a rel="next" href="g_PWM.html" target="_self" class="btnNav next" title="Suivant (Modulation en largeur l'impulsion - PWM)"><span>Suivant</span></a></li></ul></nav></div></div><div id="toolbox"><nav id="menu" class="pageSelector" role="navigation" tabindex="-1" aria-label="menu principal"><hr class="hidden"><ul class="mnu static" data-totalPages="80"><li class="sel_no anc_no type_l  dpt_0 intro"><div class="lbl type_l" id="module_Micropython_1.html"><a href="module_Micropython_1.html" target="_self" class="item"><span>Introduction</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_circuitPython.html"><a href="AA_circuitPython.html" target="_self" class="item"><span>Adafruit ? CircuitPython ?</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_edublocks.html"><a href="AA_edublocks.html" target="_self" class="item"><span>Découverte de CircuitPython avec edublocks</span></a></div></li><li class="sel_no anc_yes type_b  dpt_0 courseUa"><div class="lbl type_b" id="AA_circuitPython_1.html"><a href="AA_circuitPython_1.html" target="_self" class="item" type="up"><span>de l'Arduino vers CircuitPython</span></a></div><ul class="sub mnu_open"><li class="sel_no anc_no type_l  dpt_1 intro"><div class="lbl type_l" id="AA_circuitPython_2.html"><a href="AA_circuitPython_2.html" target="_self" class="item"><span>Introduction</span></a></div></li><li class="sel_no anc_no type_l  dpt_1 expUc"><div class="lbl type_l" id="g_intro.html"><a href="g_intro.html" target="_self" class="item"><span>Pourquoi utiliser circuitPython ?</span></a></div></li><li class="sel_no anc_no type_l  dpt_1 expUc"><div class="lbl type_l" id="g_blink.html"><a href="g_blink.html" target="_self" class="item"><span>Premier programme : blink !</span></a></div></li><li class="sel_no anc_no type_l  dpt_1 expUc"><div class="lbl type_l" id="g_button.html"><a href="g_button.html" target="_self" class="item"><span>Entrée numérique</span></a></div></li><li class="sel_yes anc_no type_l  dpt_1 expUc"><div class="lbl type_l" id="g_analogIn.html"><span class="item"><span>Entrées - sorties analogiques</span></span></div></li><li class="sel_no anc_no type_l  dpt_1 expUc"><div class="lbl type_l" id="g_PWM.html"><a href="g_PWM.html" target="_self" class="item"><span>Modulation en largeur l'impulsion - PWM</span></a></div></li></ul></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_mu.html"><a href="AA_mu.html" target="_self" class="item"><span>projets CPX</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_autresProjets.html"><a href="AA_autresProjets.html" target="_self" class="item"><span>Projets divers autour de CircuitPython</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="AA_displayio.html"><a href="AA_displayio.html" target="_self" class="item"><span>Graphisme sous CircuitPython - utilisation de displayio</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 courseUa"><div class="lbl type_b" id="aa_gameConsole.html"><a href="aa_gameConsole.html" target="_self" class="item"><span>Fabriquer sa console de jeu - Niveau avancé</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 ueDiv"><div class="lbl type_b" id="module_Micropython_2.html"><a href="module_Micropython_2.html" target="_self" class="item"><span>Objets connectés (IoT) - MicroPython sur ESP8266 et ESP32</span></a></div></li><li class="sel_no anc_no type_b  type_b_c dpt_0 ueDiv"><div class="lbl type_b" id="module_Micropython_3.html"><a href="module_Micropython_3.html" target="_self" class="item"><span>Micropython sur la carte BBC micro::bit</span></a></div></li></ul></nav><div id="tools" tabindex="-1"><hr class="hidden"><nav class="headingSelector" role="navigation"><ul class="mnu"><li class="anc_no home" data-position="uncle"><div class="lbl"><a href="module_Micropython.html" target="_self" class="item" type="index" title="Page d'accueil du module"><span>Accueil</span></a></div></li><li class="anc_yes module" data-position="ancestor"><div class="lbl"><span class="item"><span>Module</span></span></div></li></ul></nav></div></div></main><footer id="footer" role="contentinfo" tabindex="-1"><hr class="hidden"><a id="linkSp" target="_blank" href="../../../external.html?link=https://www.scenari.org/" title="R&eacute;alis&eacute; avec Scenari (nouvelle fen&ecirc;tre)"><span><img alt="R&eacute;alis&eacute; avec Scenari (nouvelle fen&ecirc;tre)" src="../skin/img/tpl/scBtn.png"></span></a></footer></div>
  <script type="text/JavaScript" src="../skin/js/skin.js"></script>
  <script type="text/javascript">tplMgr.init();scCodeMgr.init();scMediaMgr.init("ide:content/chi:div/chi:section/des:.mediaPlayer",{processYoutubeUrls :true});scImgMgr.init();outMgr.init();</script>
 </body>

<!-- Mirrored from lecluseo.scenari-community.org/CircuitPython/co/g_analogIn.html by HTTraQt Website Copier/1.x [Karbofos 2012-2017] mer., 24 août 2022 06:38:54 GMT -->
</html>
